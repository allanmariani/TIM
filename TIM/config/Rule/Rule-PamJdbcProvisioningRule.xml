<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="PAM JDBC Provisioning Rule" type="JDBCProvision">
          
    
    <Description>This rule is called on any provisioning request through the JDBC PAM engine.</Description>
          
    
    <Signature returnType="Map">
                    
        
        <Inputs>
                              
            
            <Argument name="log">
                                        
                
                <Description>
          The log object associated with the SailPointContext.
        </Description>
                                      
            
            </Argument>
                              
            
            <Argument name="context">
                                        
                
                <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
                                      
            
            </Argument>
                              
            
            <Argument name="application">
                                        
                
                <Description>
          The application whose data file is being processed
        </Description>
                                      
            
            </Argument>
                              
            
            <Argument name="connection">
                                        
                
                <Description>
          A connection object to connect to database
        </Description>
                                      
            
            </Argument>
                              
            
            <Argument name="plan">
                                        
                
                <Description>
          The ProvisioningPlan created against the JDBC application.
        </Description>
                                      
            
            </Argument>
                            
        
        </Inputs>
                    
        
        <Returns>
                              
            
            <Argument name="result">
                                        
                
                <Description>
          A ProvisioningResult with information about provisioning.
        </Description>
                                      
            
            </Argument>
                            
        
        </Returns>
                  
    
    </Signature>
          
    
    <Source><![CDATA[
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.sql.Statement;
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;

    import sailpoint.connector.Connector;
    import sailpoint.connector.ConnectorException;
    import sailpoint.connector.ConnectorFactory;
    import sailpoint.object.Application;
    import sailpoint.object.ProvisioningPlan;
    import sailpoint.object.ProvisioningPlan.AbstractRequest;
    import sailpoint.object.ProvisioningPlan.AccountRequest;
    import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
    import sailpoint.object.ProvisioningPlan.AttributeRequest;
    import sailpoint.object.ProvisioningPlan.ObjectOperation;
    import sailpoint.object.ProvisioningPlan.ObjectRequest;
    import sailpoint.object.ProvisioningResult;
    import sailpoint.object.ResourceObject;
    import sailpoint.tools.GeneralException;
    import sailpoint.tools.JdbcUtil;
    import sailpoint.tools.Util;


    String TYPE_CONTAINER = "Container";
    String TYPE_PRIVILEGED_DATA = "PrivilegedData";
    String TYPE_CONTAINER_PERMISSION = "ContainerPermission";
    String TYPE_PRIVILEGED_DATA_PERMISSION = "PrivilegedDataPermission";


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // PROVISION - The main method that gets called
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Execute the given ProvisioningPlan.
     *
     * @param app  The JDBC Application.
     * @param connection  The Connection to use to communicate with the database.
     * @param plan  The ProvisioningPlan to execute.
     *
     * @return A ProvisioningResult that contains the status and updated ResourceObject (if operation is not delete).
     *
     * @throws Exception If any errors occur while provisioning, or the ProvisioningPlan has bad data.
     */
    public static ProvisioningResult provision(Application app, Connection connection, ProvisioningPlan plan)
        throws Exception {

        String id = null;

        // Handle all account requests in the plan.
        for (AccountRequest acctReq : Util.iterate(plan.getAccountRequests())) {
            Operation op = acctReq.getOperation();

            if (Operation.Enable.equals(op) || Operation.Disable.equals(op)) {
                id = enableOrDisable(connection, acctReq.getNativeIdentity(), Operation.Enable.equals(op));
            }
            else if (Operation.Delete.equals(op)) {
                delete(connection, Connector.TYPE_ACCOUNT, acctReq.getNativeIdentity());
            }
            else if (Operation.Create.equals(op) || Operation.Modify.equals(op)) {
                id = createOrUpdate(connection, app, acctReq);
            }
            else {
                throw new ConnectorException("Unhandled account operation - " + op);
            }
        }

        // Handle all object requests in the plan.
        for (ObjectRequest objReq : Util.iterate(plan.getObjectRequests())) {
            ObjectOperation op = objReq.getOp();

            if (ObjectOperation.Delete.equals(op)) {
                delete(connection, objReq.getType(), objReq.getNativeIdentity());
            }
            else if (ObjectOperation.Create.equals(op) || ObjectOperation.Modify.equals(op)) {
                id = createOrUpdate(connection, app, objReq);
            }
            else {
                throw new ConnectorException("Unhandled object operation - " + op);
            }
        }

        // Create a provisioning result with the updated/created object in it.  Note that for a delete
        // the ID is null, so there will be no object to return.
        ProvisioningResult result = new ProvisioningResult();
        result.setObject(loadObject(app, id, plan));
        return result;
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // ENABLE / DISABLE
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Enable or disable the account with the given native identity.
     *
     * @param conn  The database connection to use.
     * @param nativeIdentity  The native identity of the account to enable/disable.
     * @param isEnable  Whether to enable the account, false indicates disable.
     *
     * @return The ID of the account that was enabled/disabled.
     */
    private static String enableOrDisable(Connection conn, String nativeIdentity, boolean isEnable) throws Exception {
        int activeValue = (isEnable) ? 1 : 0;

        String sql = "update users set active = ? where id = ?";
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement(sql);
            stmt.setInt(1, activeValue);
            stmt.setString(2, nativeIdentity);
            int updated = stmt.executeUpdate();
            handleUpdateResult(updated);
        }
        finally {
            JdbcUtil.closeStatement(stmt);
        }

        return nativeIdentity;
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // DELETE
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Delete the given object.
     *
     * @param conn  The database connection to use.
     * @param objectType  The type of the object to delete.
     * @param nativeIdentity  The native identity of the object to delete.
     */
    private static void delete(Connection conn, String objectType, String nativeIdentity) throws Exception {
        // First, clean up any references to the object being deleted.
        cleanForeignKeys(conn, objectType, nativeIdentity);

        // Delete the actual object - we expect a single row to be deleted.
        delete(conn, getTableName(objectType), "id", nativeIdentity, true);
    }

    /**
     * Clean up any foreign key references for the given object that is about to be deleted.
     *
     * @param conn  The database connection to use.
     * @param objectType  The type of the object for which the foreign keys should be cleaned.
     * @param nativeIdentity  The native identity of the object for which the foreign keys should be cleaned.
     */
    private static void cleanForeignKeys(Connection conn, String objectType, String nativeIdentity) throws Exception {
        if (Connector.TYPE_ACCOUNT.equals(objectType)) {
            delete(conn, "user_group_assignments", "user_id", nativeIdentity, false);
            delete(conn, "container_permission_assignments", "user_id", nativeIdentity, false);
            delete(conn, "priv_data_permission_assignments", "user_id", nativeIdentity, false);
        }
        else if (Connector.TYPE_GROUP.equals(objectType)) {
            delete(conn, "user_group_assignments", "group_id", nativeIdentity, false);
            delete(conn, "container_permission_assignments", "group_id", nativeIdentity, false);
            delete(conn, "priv_data_permission_assignments", "group_id", nativeIdentity, false);
            setNull(conn, "groups", "parent_group_id", nativeIdentity);
        }
        else if (TYPE_CONTAINER.equals(objectType)) {
            delete(conn, "container_priv_data_assignments", "container_id", nativeIdentity, false);
            delete(conn, "container_permission_assignments", "container_id", nativeIdentity, false);
        }
        else if (TYPE_PRIVILEGED_DATA.equals(objectType)) {
            delete(conn, "container_priv_data_assignments", "privileged_data_id", nativeIdentity, false);
            delete(conn, "priv_data_permission_assignments", "privileged_data_id", nativeIdentity, false);
        }
    }

    /**
     * Delete the rows from the given table where the value matches for the given column.
     *
     * @param conn  The database connection to use.
     * @param tableName  The name of the table to delete from.
     * @param column  The name of the column being compared in the WHERE clause.
     * @param value  The value to compare the column against in the WHERE clause.
     * @param expectSingleUpdate  Whether to expect that a single row will have been deleted.  If true, and the delete
     *     operation does not affect a single row, an exception is thrown.
     */
    private static void delete(Connection conn, String tableName, String column, String value, boolean expectSingleUpdate)
        throws Exception {

        String sql = "delete from " + tableName + " where " + column + " = ?";
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement(sql);
            stmt.setString(1, value);
            int updated = stmt.executeUpdate();

            if (expectSingleUpdate) {
                handleUpdateResult(updated);
            }
        }
        finally {
            JdbcUtil.closeStatement(stmt);
        }
    }

    /**
     * Set the given column to null when its value matches the given value.
     *
     * @param conn  The database connection to use.
     * @param tableName  The name of the table to set the null values on.
     * @param column  The name of the column to null out, and which we compare the value against.
     * @param value  The value to match for the given column.
     */
    private static void setNull(Connection conn, String tableName, String column, String value)
        throws Exception {

        String sql = "update " + tableName + " set " + column + " = NULL where " + column + " = ?";
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement(sql);
            stmt.setString(1, value);
            int updated = stmt.executeUpdate();
            handleUpdateResult(updated);
        }
        finally {
            JdbcUtil.closeStatement(stmt);
        }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // CREATE / UPDATE
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Create or update an object using the given request.
     *
     * @param conn  The database connection to use.
     * @param app  The JDBC Application.
     * @param objReq  The request to execute.
     *
     * @return The ID of the object that was created/updated.
     */
    private static String createOrUpdate(Connection conn, Application app, AbstractRequest objReq)
        throws Exception {

        String objectType = getObjectType(objReq);
        String nativeIdentity = objReq.getNativeIdentity();

        if ((null == nativeIdentity) && ObjectOperation.Modify.equals(objReq.getOp())) {
            throw new ConnectorException("nativeIdentity is required for a modify operation");
        }

        // Create or update the object.
        Map values = getValues(app, objReq, objectType);
        nativeIdentity = createOrUpdate(conn, objectType, values, nativeIdentity);

        // Handle any attributes that need to be provisioned on other tables, such as group membership.
        provisionSecondaryTables(conn, app, objReq, nativeIdentity);

        return nativeIdentity;
    }

    /**
     * Return the object type for the given request.
     */
    private static String getObjectType(AbstractRequest objReq) {
        String type = objReq.getType();
        return (null != type) ? type : Connector.TYPE_ACCOUNT;
    }

    /**
     * Create a Map that maps a table column name to the value to set for that column.
     *
     * @param app  The JDBC Application.
     * @param objReq  The request for which to create the value map.
     * @param objectType  The type of object represented in the request.
     *
     * @return A Map that maps a table column name to the value to set for that column.
     */
    private static Map getValues(Application app, AbstractRequest objReq, String objectType)
        throws ConnectorException {

        Map values = new HashMap();

        for (AttributeRequest attrReq : Util.iterate(objReq.getAttributeRequests())) {
            // If this attribute is managed in a secondary table, it will be handled later.
            if (isAttributeInSecondaryTable(attrReq.getName(), objectType)) {
                continue;
            }

            ProvisioningPlan.Operation op = attrReq.getOperation();
            String column = getColumn(attrReq.getName(), objectType);

            if (null == column) {
                log.info("Ignoring setting '" + attrReq.getName() + "' since there is not mapped in the database");
            }
            else {
                Object value = getValue(attrReq.getName(), attrReq.getValue(), objectType);

                if (ProvisioningPlan.Operation.Set.equals(op)) {
                    values.put(column, value);
                }
                else {
                    throw new ConnectorException("Unhandled attribute operation - only single-valued Set is handled: " + op);
                }
            }
        }

        // Note that none of these requests should have permissions.  Even ContainerPermission and
        // PrivilegedDataPermission requests will have been changed to AttributeRequests before they
        // are sent.

        return values;
    }

    /**
     * Return whether the given attribute should be provisioned in a secondary table - not inlined in the primary table.
     *
     * @param attrName  The name of the attribute.
     * @param objectType  The type of object being provisioned.
     *
     * @return True if the given attribute should be provisioned in a secondary table, false otherwise.
     */
    private static boolean isAttributeInSecondaryTable(String attrName, String objectType) {
        return isGroupMembersAttribute(attrName, objectType) || isContainerPrivilegedDataAttribute(attrName, objectType);
    }

    /**
     * Return whether the given attribute is the "members" attribute on Group.
     */
    private static boolean isGroupMembersAttribute(String attrName, String objectType) {
        return Connector.TYPE_GROUP.equals(objectType) && "members".equals(attrName);
    }

    /**
     * Return whether the given attribute is the "members" attribute on Group.
     */
    private static boolean isContainerPrivilegedDataAttribute(String attrName, String objectType) {
        return TYPE_CONTAINER.equals(objectType) && "privilegedData".equals(attrName);
    }

    /**
     * Provision any attributes in the given request to secondary tables, if any exist.
     *
     * @param conn  The database connection to use.
     * @param app  The JDBC application.
     * @param objReq  The request in which to look for secondary attributes to provision.
     * @param nativeIdentity  The native identity of the object being provisioned.
     */
    private static void provisionSecondaryTables(Connection conn, Application app, AbstractRequest objReq, String nativeIdentity)
        throws ConnectorException, SQLException, GeneralException {

        String objectType = getObjectType(objReq);

        for (AttributeRequest attrReq : Util.iterate(objReq.getAttributeRequests())) {
            if (isGroupMembersAttribute(attrReq.getName(), objectType)) {
                provisionGroupMembership(conn, app, attrReq, nativeIdentity);
            }

            // TODO: implement provisioning for a container's privileged data, any others?
        }
    }

    /**
     * Provision the membership changes in the given attribute request.
     *
     * @param conn  The connection to use.
     * @param app  The JDBC application.
     * @param groupAttrReq  The AttributeRequest with the group changes.
     * @param groupId  The ID of the group to change.
     */
    private static void provisionGroupMembership(Connection conn, Application app, AttributeRequest groupAttrReq, String groupId)
        throws ConnectorException, SQLException, GeneralException {

        // The attribute request contains the ID's of the members that should be added/removed from the group.
        List userIds = Util.asList(groupAttrReq.getValue());
        ProvisioningPlan.Operation op = groupAttrReq.getOperation();

        List usersToAdd = new ArrayList();
        List usersToRemove = new ArrayList();

        // Determine which users to add/remove.
        if (ProvisioningPlan.Operation.Add.equals(op)) {
            usersToAdd = userIds;
        }
        else if (ProvisioningPlan.Operation.Remove.equals(op)) {
            usersToRemove = userIds;
        }
        else if (ProvisioningPlan.Operation.Set.equals(op)) {
            // If we are setting, we need to load the current membership and determine which need to be added
            // or removed based on the desired state.
            ResourceObject group = loadObject(app, Connector.TYPE_GROUP, groupId);
            List currentMembers = group.getStringList("members");
            usersToAdd = getAddedItems(currentMembers, userIds);
            usersToRemove = getRemovedItems(currentMembers, userIds);
        }

        // Execute the add/remove operations.
        for (String userToAdd : Util.iterate(usersToAdd)) {
            provisionGroupMember(conn, groupId, userToAdd, true);
        }
        for (String userToRemove : Util.iterate(usersToRemove)) {
            provisionGroupMember(conn, groupId, userToRemove, false);
        }
    }

    /**
     * Return a list of values that have been added to the newList that are not in the previousList.
     *
     * @param previousList  The previous list to compare against.
     * @param newList  The list in which to look for added items.
     *
     * @return A possibly-null list of items added to the new list.
     */
    private static List getAddedItems(List previousList, List newList) {
        // If there is nothing in the previous list, then everything is an add.
        if (Util.isEmpty(previousList)) {
            return newList;
        }

        // If the new list is not null, figure out which items have been added.
        if (null != newList) {
            List added = new ArrayList(newList);
            added.removeAll(previousList);
            return added;
        }

        // Both lists were null or empty, return null.
        return null;
    }

    /**
     * Return a list of values that have been removed from the previousList that are no longer in the newList.
     *
     * @param previousList  The previous list to compare against.
     * @param newList  The list in which to look for removed items.
     *
     * @return A possibly-null list of items removed from the new list.
     */
    private static List getRemovedItems(List previousList, List newList) {
        return getAddedItems(newList, previousList);
    }

    /**
     * Add or remove the given group user to the given group.  This will not try to add a user that is already a
     * member of the group.
     *
     * @param conn  The connection to use.
     * @param groupId  The ID of the group to add/remove the member on.
     * @param userId  The ID of the user to add/remove on the group.
     * @param isAdd  Whether to add the user.  If false, the user is removed from the group.
     */
    private static void provisionGroupMember(Connection conn, String groupId, String userId, boolean isAdd)
        throws ConnectorException, SQLException {

        String sql = null;

        if (isAdd) {
            // We only want to add this group member if they are not already a member.
            if (!doesGroupAssignmentExist(conn, groupId, userId)) {
                sql = "insert into user_group_assignments (user_id, group_id) values (?, ?)";
            }
            else {
                log.info("Not adding user '" + userId + "' to group '" + groupId + "' - already a member");
            }
        }
        else {
            sql = "delete from user_group_assignments where user_id = ? and group_id = ?";
        }

        // This may be null if the user being added is already a member.
        if (null != sql) {
            PreparedStatement stmt = null;
            try {
                stmt = conn.prepareStatement(sql);
                stmt.setString(1, userId);
                stmt.setString(2, groupId);
                stmt.executeUpdate();
            }
            finally {
                JdbcUtil.closeStatement(stmt);
            }
        }
    }

    /**
     * Return whether the given group already has the given user as a member.
     *
     * @param conn  The connection to use.
     * @param groupId  The ID of the group to check.
     * @param userId  The ID of the user to look for.
     *
     * @return True if the user is a member of the group, false otherwise.
     */
    private static boolean doesGroupAssignmentExist(Connection conn, String groupId, String userId)
        throws SQLException, ConnectorException {

        String sql = "select count(*) from user_group_assignments where user_id = ? and group_id = ?";
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            stmt = conn.prepareStatement(sql);
            stmt.setString(1, userId);
            stmt.setString(2, groupId);
            rs = stmt.executeQuery();

            if (!rs.next()) {
                throw new ConnectorException("Expected a single row for a count query");
            }
            int count = rs.getInt(1);
            return (count > 0);
        }
        finally {
            JdbcUtil.closeResult(rs);
            JdbcUtil.closeStatement(stmt);
        }
    }

    /**
     * Return the name of the column in the database that corresponds to the given attribute.
     *
     * @param attrName  The name of the attribute.
     * @param objectType  The type of object that the attribute is on.
     *
     * @return The column name, or null if the given attribute is not mapped in the database.
     */
    private static String getColumn(String attrName, String objectType) {

        // Unmapped attributes.
        if ("entitlements".equals(attrName)) {
            return null;
        }
        else if ("roles".equals(attrName)) {
            return null;
        }
        else if ("sourceNativeIdentifier".equals(attrName)) {
            return null;
        }
        else if ("source".equals(attrName)) {
            return null;
        }

        // Columns whose names differ.
        if (Connector.TYPE_ACCOUNT.equals(objectType)) {
            if ("firstname".equalsIgnoreCase(attrName)) {
                return "givenName";
            }
            else if ("lastname".equalsIgnoreCase(attrName)) {
                return "familyName";
            }
            else if ("IIQDisabled".equalsIgnoreCase(attrName)) {
                return "active";
            }
        }
        else if (TYPE_CONTAINER.equals(objectType) || TYPE_PRIVILEGED_DATA.equals(objectType)) {
            if ("owner".equalsIgnoreCase(attrName)) {
                return "ownerId";
            }
        }
        else if (TYPE_CONTAINER_PERMISSION.equals(objectType) || TYPE_PRIVILEGED_DATA_PERMISSION.equals(objectType)) {
            if ("container".equalsIgnoreCase(attrName)) {
                return "container_id";
            }
            else if ("privilegedData".equalsIgnoreCase(attrName)) {
                return "privileged_data_id";
            }
            else if ("user".equalsIgnoreCase(attrName)) {
                return "user_id";
            }
            else if ("group".equalsIgnoreCase(attrName)) {
                return "group_id";
            }
        }

        // If there is no mapping, just return the attribute name.
        return attrName;
    }

    /**
     * Return the value to set in the database for the given attribute.  This can transform values into something more
     * appropriate for the database.
     *
     * @param attrName  The name of the attribute being set.
     * @param value  The value from the provisioning plan.
     * @param objectType  The type of the object on which the value is being set.
     *
     * @return  The value to set.
     */
    private static Object getValue(String attrName, Object value, String objectType) {

        // Disabled is represented as "active" on Users, so we need to invert the value.
        if (Connector.TYPE_ACCOUNT.equals(objectType)) {
            if ("IIQDisabled".equalsIgnoreCase(attrName)) {
                return !Util.otob(value);
            }
        }

        // Otherwise, no transformation, so just return the value.
        return value;
    }

    /**
     * Create or update an object by setting the given values.
     *
     * @param conn  The database connection to use.
     * @param objectType  The type of object to create or update.
     * @param values  The values to set in the database, mapped by column name.
     * @param nativeIdentity  The native identity of the object to update, or null if creating.
     *
     * @return The ID of the updated or created object.
     */
    private static String createOrUpdate(Connection conn, String objectType, Map values, String nativeIdentity)
        throws Exception {

        String tableName = getTableName(objectType);

        if (null != nativeIdentity) {
            update(conn, tableName, values, nativeIdentity);
        }
        else {
            nativeIdentity = create(conn, objectType, tableName, values);
        }

        return nativeIdentity;
    }

    /**
     * Create an object by inserting the given values into the given table.  This will optionally create an ID for
     * the object or allow the database to do this, depending insertRequiresID().
     *
     * @param conn  The database connection to use.
     * @param objectType  The type of object to create.
     * @param tableName  The name of the table to insert into.
     * @param values  A map of column names mapped to the value to set.
     *
     * @return The ID of the newly created object.
     */
    private static String create(Connection conn, String objectType, String tableName, Map values)
        throws SQLException, ConnectorException {

        // The SQL will end up looking like:
        //   insert into users (name, blah) values ('jimmy', 'foo')
        String newId = null;

        // Get a set of keys for the value map with a consistent order.
        List keys = new ArrayList(values.keySet());

        boolean autoGenerateId = !insertRequiresID(objectType);

        String sql = "insert into " + tableName + " (";

        // Add the names of the columns being inserted.
        String sep = "";
        for (String key : keys) {
            sql += sep + key;
            sep = ", ";
        }

        // If we are supplying an ID, add the ID column name.
        if (!autoGenerateId) {
            sql += ", " + getIDColumn(objectType);
        }

        sql += ") values (";

        // Add the values to set for the columns.  We need one extra value if we are supplying the ID.
        int numValues = (!autoGenerateId) ? keys.size() + 1 : keys.size();
        sep = "";
        for (int i = 0; i < numValues; i++) {
            sql += sep + "?";
            sep = ", ";
        }

        sql += ")";

        int returnKeys = (autoGenerateId) ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS;
        PreparedStatement stmt = null;

        try {
            // Prepare a statement with the given values.
            stmt = conn.prepareStatement(sql, returnKeys);
            setParameters(stmt, values, keys);

            // If we are supplying an ID, generate one and set it on the statement.
            if (!autoGenerateId) {
                newId = generateID(objectType);
                stmt.setString(keys.size() + 1, newId);
            }

            // Insert the object.
            int updated = stmt.executeUpdate();
            handleUpdateResult(updated);

            // If the database generated the ID, retrieve it from the statement.
            if (autoGenerateId) {
                ResultSet rs = null;
                try {
                    rs = stmt.getGeneratedKeys();
                    if (!rs.next()) {
                        throw new ConnectorException("Could not read generated key from insert statement - " + sql);
                    }
                    newId = Long.toString(rs.getLong(1));
                }
                finally {
                    JdbcUtil.closeResult(rs);
                }
            }
        }
        finally {
            JdbcUtil.closeStatement(stmt);
        }

        return newId;
    }

    /**
     * Return true if the given object type requires an ID to be supplied when inserting a row.  If this is true,
     * getIDColumn() and generateID() should both return values for this objectType.
     * @throws ConnectorException 
     */
    private static boolean insertRequiresID(String objectType) throws ConnectorException {
        // Any string ID columns are managed by us, any number ID columns are auto-generated.
        return isIDString(getTableName(objectType));
    }

    /**
     * Return the name of the ID column if the given object type requires an ID to be supplied when inserting a row.
     */
    private static String getIDColumn(String objectType) {
        return "id";
    }

    /**
     * Return whether the given table uses a string for its ID.
     *
     * @param tableName  The name of the table.
     *
     * @return True if the table uses a string for its ID, false otherwise.
     */
    private static boolean isIDString(String tableName) {
        return !"container_permission_assignments".equals(tableName) && !"priv_data_permissions".equals(tableName);
    }

    /**
     * Return generated ID if the given object type requires an ID to be supplied when inserting a row.
     */
    private static String generateID(String objectType) {
        return Util.uuid();
    }

    /**
     * Update the given table by setting the columns to the values supplied in the values Map.
     *
     * @param conn  The database connection to use.
     * @param tableName  The name of the table to update.
     * @param values  A Map of column names to values to be updated.
     * @param nativeIdentity  The native identity of the object to update.
     */
    private static void update(Connection conn, String tableName, Map values, String nativeIdentity)
        throws SQLException, ConnectorException {

        // The SQL will end up looking like:
        //   update users set name = 'jimmy', blah = 'foo' where id = '1234'

        // Get a set of keys for the value map with a consistent order.
        List keys = new ArrayList(values.keySet());

        String sql = "update " + tableName + " set ";

        String sep = "";
        for (String key : keys) {
            sql += sep + key + " = ?";
            sep = ", ";
        }

        sql += " where id = ?";

        PreparedStatement stmt = null;

        try {
            stmt = conn.prepareStatement(sql);
            setParameters(stmt, values, keys);
    
            // Add the ID parameter value (note that the indexes are 1-based.
            if (isIDString(tableName)) {
                stmt.setString(keys.size() + 1, nativeIdentity);
            }
            else {
                stmt.setInt(keys.size() + 1, Integer.valueOf(nativeIdentity));
            }
    
            int numUpdated = stmt.executeUpdate();
            handleUpdateResult(numUpdated);
        }
        finally {
            JdbcUtil.closeStatement(stmt);
        }
    }

    /**
     * Set the parameters on the PreparedStatement to the given values, in the order of the keys.
     *
     * @param stmt  The statement to set the parameter values on.
     * @param values  A Map of column name to value to set.
     * @param keys  An ordered list of keys, which specify the index of each parameter being set.
     */
    private static void setParameters(PreparedStatement stmt, Map values, List keys)
        throws SQLException, ConnectorException {

        for (int i = 0; i < keys.size(); i++) {
            String key = keys.get(i);
            int paramIdx = i + 1;
            Object value = values.get(key);

            if ((null == value) || (value instanceof String)) {
                stmt.setString(paramIdx, (String) value);
            }
            else if (value instanceof Integer) {
                stmt.setInt(paramIdx, (Integer) value);
            }
            else if (value instanceof Long) {
                stmt.setLong(paramIdx, (Long) value);
            }
            else if (value instanceof Double) {
                stmt.setDouble(paramIdx, (Double) value);
            }
            else if (value instanceof Float) {
                stmt.setFloat(paramIdx, (Float) value);
            }
            else if (value instanceof Boolean) {
                stmt.setBoolean(paramIdx, (Boolean) value);
            }
            else if (value instanceof List) {
                stmt.setString(paramIdx, Util.listToCsv((List) value));
            }
            else {
                throw new ConnectorException("Unknown data type for " + value + ": " + value.getClass());
            }
        }
    }

    /**
     * Load a ResourceObject being provisioned by the given plan, or return null if the nativeIdentity is null.
     *
     * @param app  The JDBC Application.
     * @param nativeIdentity  The native identity of the object to load, or null if an object should not be loaded.
     * @param plan  The ProvisioningPlan, from which the object type can be determined.
     *
     * @return A ResourceObject, or null if the native identity is null.
     */
    private static ResourceObject loadObject(Application app, String nativeIdentity, ProvisioningPlan plan)
        throws ConnectorException, GeneralException {

        if (null == nativeIdentity) {
            return null;
        }

        String objectType = null;
        if (!Util.isEmpty(plan.getAccountRequests())) {
            objectType = Connector.TYPE_ACCOUNT;
        }
        else if (!Util.isEmpty(plan.getObjectRequests())) {
            objectType = plan.getObjectRequests().get(0).getType();
        }

        if (null == objectType) {
            throw new ConnectorException("Could not determine object type");
        }

        return loadObject(app, objectType, nativeIdentity);
    }

    /**
     * Load a ResourceObject by native identity.
     *
     * @param app  The JDBC Application.
     * @param objectType  The type of object to load.
     * @param nativeIdentity  The native identity of the object to load, or null if an object should not be loaded.
     *
     * @return A ResourceObject.
     */
    private static ResourceObject loadObject(Application app, String objectType, String nativeIdentity)
        throws GeneralException, ConnectorException {

        Connector conn = ConnectorFactory.getConnector(app, null);
        return conn.getObject(objectType, nativeIdentity, null);
    }

    /**
     * Throw an exception if a single row was not updated.
     */
    private static void handleUpdateResult(int numUpdated) throws ConnectorException {
        if (1 != numUpdated) {
            throw new ConnectorException("Expected a single row to be updated - actual update count: " + numUpdated);
        }
    }

    /**
     * Return the table name for the given object type.
     */
    private static String getTableName(String objectType) throws ConnectorException {
        // Assume an account request for a null type.
        objectType = (null != objectType) ? objectType : Connector.TYPE_ACCOUNT;

        switch (objectType) {
        case Connector.TYPE_ACCOUNT: return "users";
        case Connector.TYPE_GROUP: return "groups";
        case TYPE_CONTAINER: return "containers";
        case TYPE_PRIVILEGED_DATA: return "privileged_data";
        case TYPE_CONTAINER_PERMISSION: return "container_permission_assignments";
        case TYPE_PRIVILEGED_DATA_PERMISSION: return "priv_data_permission_assignments";
        }

        throw new ConnectorException("Unknown schema type: " + objectType);
    }


    // PROVISION!
    return provision(application, connection, plan);
  ]]></Source>
        

</Rule>
